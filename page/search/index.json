[{"content":"nachos file system if we want to show a project, we will \u0026hellip;\n","date":"2024-02-05T19:49:28+08:00","permalink":"https://leo00932302.github.io/post/nachos/","title":"file system"},{"content":"作業系統簡介 此網站為作業系統的筆記，涵蓋每個單元，包含附錄。\n第一章 第二章 第三章 ","date":"2024-01-31T00:08:50+08:00","permalink":"https://leo00932302.github.io/post/os/","title":"作業系統"},{"content":"大一上學期(個體經濟學期中考) ","date":"2024-01-31T00:08:50+08:00","permalink":"https://leo00932302.github.io/post/%E8%80%83%E5%8F%A4%E9%A1%8C/%E7%B6%93%E6%BF%9F%E5%AD%B8/","title":"經濟學考古題"},{"content":"binary search tree #include \u0026lt;stdio.h\u0026gt; int binsearch(int yarr[10], int element) { int mid = sizeof(yarr) % 2; int left = (int)yarr / 2 - mid; int right = yarr - left; extern int i; if(element == mid) printf(\u0026#34;%d\u0026#34;, \u0026amp;mid); if(element != yarr[right]) { for(i = 0; i \u0026lt; left; i++) { if(element == i) { //Does this so that it doesn\u0026#39;t print multiple times printf(\u0026#34;%d\u0026#34;, i); } } } }; int main(int argc, int argv[]) { binsearch(argv[0], argv[1]); } bst implement // Implementation of Binary Search Tree #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct BST { int data; struct BST* left; struct BST* right; }; struct BST *CreateNode() { struct BST* new = (struct BST*) malloc(sizeof(struct BST)); new-\u0026gt;left = NULL; new-\u0026gt;right = NULL; return new; }; void Insert(struct BST** RootPtr, int value) { struct BST* temp = *RootPtr; if (temp == NULL) { /*When list is empty*/ struct BST* NewNode = CreateNode(); NewNode-\u0026gt;data = value; *RootPtr = NewNode; } else if (value \u0026lt;= temp-\u0026gt;data) { /*If user value is less then current node value insert in left of the node...*/ struct BST* NewNode = CreateNode(); NewNode-\u0026gt;data = value; temp-\u0026gt;left = NewNode; } else { /*If user value is greater then current node value insert at right of the node*/ struct BST* NewNode = CreateNode(); NewNode-\u0026gt;data = value; temp-\u0026gt;right = NewNode; } } int Search(struct BST* RootPtr, int item) { /*Implemented search using recursion*/ if(RootPtr == NULL) { return 0; /*Returns 0 if list is empty*/ } else if(item == RootPtr-\u0026gt;data) { return 1; /*Returns 1 when element found*/ } else if(item \u0026lt; RootPtr-\u0026gt;data) { Search(RootPtr-\u0026gt;left, item); /*Otherwise search in left side of binary tree if searching value is less then the current node value*/ } else { Search(RootPtr-\u0026gt;right, item); /*Otherwise search in right side of binary tree if searching value is greater then the current node value*/ } } void main() { struct BST* RootPtr = NULL; int item, cont, key; do { printf(\u0026#34;Enter item: \u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;item); Insert(\u0026amp;RootPtr, item); printf(\u0026#34;\\n1 to keep inserting/ 0 to Exit: \u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;cont); } while(cont == 1); printf(\u0026#34;\\nEnter element to search: \u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;key); if(Search(RootPtr, key) == 0) { printf(\u0026#34;\\nFound\\n\u0026#34;); } else { printf(\u0026#34;\\nNot Found\\n\u0026#34;); } } ","date":"2024-01-27T02:12:31+08:00","permalink":"https://leo00932302.github.io/post/algorithom/algorithom/","title":"alogrithom"},{"content":"0.1 取得程式碼 本書的原始碼可以在GitHub上找到，網址是 https://github.com/dev-cafe/cmake-cookbook 。 開源程式碼遵循MIT許可：只要原始版權和許可聲明包含在軟體/原始碼的任何副本中，可以以任何方式重複使用和重新混合程式碼。 授權的全文可以在 https://opensource.org/licenses/MIT 中看到。\n為了測試原始碼，需要使用Git取得程式碼：\n主要的GNU/Linux發行版都可以透過套件管理器安裝Git。 也可以從Git專案網站 https://gitscm.com 下載二進位發行版，進行安裝。 MacOS上，可使用自製或MacPorts安裝Git。 Windows上，可以從git專案網站( https://git-scm.com )下載git執行安裝檔。 可以透過github桌面用戶端存取這些範例，網址為 https://desktop.github.com 。\n另一個選擇是從 https://github.com/dev-cafe/cmake-cookbook 下載zip檔。\n安裝Git後，可以將遠端庫克隆到本機，如下所示：\n$ git clone https://github.com/dev-cafe/cmake-cookbook.git 這將建立一個名為cmake-cookbook的資料夾。 本書內容與原始碼的章節對應，書中章節的編號和源碼的順序相同。\n在GNU/Linux、MacOS和Windows上，使用最新的持續整合進行測試。 我們會在之後討論測試的設定。\n我們用標籤v1.0標記了與本書中列印的範例相對應的版本。 為了與書中內容對應，可以如下取得此特定版本：\n$ git clone --single-branch -b v1.0 https://github.com/dev-cafe/cmake-cookbook.git 我們希望收到Bug修復，並且Github庫將繼續發展。 若要取得更新，可以選擇庫的master分支。\n","date":"2024-01-27T02:12:31+08:00","permalink":"https://leo00932302.github.io/post/cmake/cmake/","title":"Cmake"},{"content":"常見資料夾命名 utils 通常用來放置一些通用文件，可在多個專案重複使用，提升開發效率。\nsrc 指source code，裡面用來存放專案的程式碼。\nlib library,用來存放庫。\ndist distribution，用來放編譯過後的文件。\nbuild 放置構建後的文件。\nconfig 存放一些基本設定，像是編譯方式之類的。\nassets 存放一些專案會用到的圖片。\nexample,demo 用來放專案的使用範例，可以在一些庫的裡面發現。\nbin 命令腳本，若使用命令工具會遇到，有些需要加入windows環境變數，用來操作command line。\n","date":"2024-01-27T02:12:31+08:00","permalink":"https://leo00932302.github.io/post/commen-sence/","title":"commen sence"},{"content":"學習如何使用git的各種命令和概念 git簡介 git是一種版本管理工具，在寫程式時可以像玩遊戲一樣設立存檔點，方便日後程式出問題時有機會回復到之前的某個狀態，也方便團隊做開發，對大一點 的程式尤為重要，其中又些更複雜的觀念，熟悉後才可提高日後的開發和協作效率。\ngit 下載 須先下載: $ https://git-scm.com/downloads\ngit基本命令(未考慮github時) git add. ","date":"2024-01-27T02:12:31+08:00","permalink":"https://leo00932302.github.io/post/git/","title":"git tutorial"},{"content":"資料結構 想學好資料結構的第一步就要先知道，資料結構本身和演算法的關係密不可分，所以兩本課本內容相似的地方非常多，若要說差在哪裡， 資料結構重視資料的儲存方式，演算法在乎取用這些資料的方式。一個好的資料結構並不一定代表儲存空間越小，因為使用越小的儲存 空間可能會帶來取用的不便利，也就是說會加重演算法的負擔。而根據目的的不同選擇不同的演算法及資料結構，使其可應對大多數狀況 則是工程師的工作。\n簡單的排序問題: //the programe using c++ and vector #incude\u0026lt;iostream\u0026gt; using namespace std; void bubble_sort(vector\u0026lt;int\u0026gt;vec){ for(int ix=0;ix\u0026lt;vec.size();ix++){ for(int jx=ix;jx\u0026lt;vec.size();jx++){ if(vec[jx]\u0026gt;vec[jx+1]){ swap(vec[jx],vec[jx+1]); } } } } ","date":"2024-01-23T23:23:04+08:00","permalink":"https://leo00932302.github.io/post/data-structure/","title":"資料結構簡介"}]